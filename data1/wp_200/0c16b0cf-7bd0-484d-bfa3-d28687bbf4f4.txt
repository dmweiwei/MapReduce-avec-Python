Un système d'exploitation est multitâche (en anglais : multitasking) s'il permet d'exécuter, de façon apparemment simultanée, plusieurs programmes informatiques. On parle également de multiprogrammation.
Cette fonction est indépendante du nombre de processeurs présents physiquement dans l'ordinateur (un système multiprocesseur n'est pas nécessaire pour exécuter un système d'exploitation multitâche).

Concept
La simultanéité apparente est le résultat de l'alternance rapide d'exécution des processus présents en mémoire. Le passage de l'exécution d'un processus à un autre est appelé commutation de contexte. Ces commutations peuvent être initiées par les programmes eux-mêmes (multitâche coopératif) ou par le système d'exploitation lors d'événements externes (multitâche préemptif).

Historique
Le premier ordinateur multitâche dans le monde a été conçu par la firme Bull en 1958. Il s'agissait du Gamma 60. Cet ordinateur ne possédait toutefois pas encore de langage de programmation à la hauteur des performances du système d'exploitation.
Les systèmes multitâches se sont ensuite répandus dans le courant des années 1960 dans une double déclinaison : Systèmes à temps partagé. Ils permettaient à plusieurs utilisateurs de travailler sur la même machine (pour des questions de rentabilité, le matériel étant extrêmement coûteux). Des exemples sont la série 5000 de Burroughs (1961-1971), l'IBM 360-67, le General Electric GE 635 ou le Scientific Data Systems (qui deviendra par la suite Xerox Data Systems) SDS-XDS Sigma 7 (commercialisé quelque temps en France sous le nom de CII 10070). Système temps réel pour la commande de processus industriels : de nombreux programmes de petite taille s'exécutaient à la réception d'événements externes (acquisition de données, alerte d'un équipement...) dans un mode de gestion par interruptions avec priorités d'exécution. Des exemples sont l'IBM 1800 ou la série des PDP de DEC.

Multitâche coopératif
Le multitâche coopératif est une forme simple de multitâche où chaque processus doit explicitement permettre à une autre tâche de s'exécuter. Il a été utilisé, par exemple, dans les produits Microsoft Windows jusqu'à Windows 3.11 ou dans Mac OS jusqu'à Mac OS 9. Cette approche simplifie l'architecture du système d'exploitation mais présente plusieurs inconvénients : Si un des processus ne redonne pas la main à un autre processus, par exemple si le processus est bugué, le système entier peut s'arrêter.; Le partage des ressources (temps CPU, mémoire, accès disque, etc.) peut être inefficace.; Le multitâche coopératif est une forme de couplage fort.

Multitâche préemptif
Pour remédier à cette situation, les systèmes grand public ont évolué pour utiliser une approche nommée "multitâche préemptif". Dans un tel système, le processeur signale au système d'exploitation que le processus en cours d'exécution doit être mis en pause pour permettre l'exécution d'un autre processus. Le système doit alors sauver l'état du processus en cours (le compteur ordinal, les valeurs des registres) ; le processus est placé dans une file d'attente ; lorsqu'il est en bout de file, son contexte d'exécution est restauré. À la différence du "multitâche coopératif", du point de vue des programmes préemptés, la commutation de contexte est transparente.
Unix (1969) et ses dérivés (BSD en 1977, Linux en 1991,..) sont des systèmes basés sur le multitâche préemptif.
Sinclair QDOS (1984), AmigaOS (1985), NeXTSTEP (1989) ou BeOS (1991) sont des systèmes multitâches préemptif depuis leur naissance. D'autres systèmes d'exploitation le sont devenus comme Windows (avec Windows NT 3.1 en 1993 pour les professionnels et Windows 95 en 1995 pour le grand public) et Mac OS X en 2001.

Cas particuliers
Le cas de Windows 95 (ainsi que de Windows 98 et ME) est particulier dans le contexte du multitâche. Ces systèmes embarquent en effet un multitâche "hybride", dans certains cas agissant en multitâche préemptif, dans d'autres, en multitâche coopératif. La conception de ces systèmes d'exploitation était en effet régie par la nécessité de faire fonctionner des programmes conçus pour Windows 3.X (multitâche coopératif) en parallèle avec des exécutables exclusivement conçus pour Windows NT-95 (multitâche préemptif). Les programmes conçus pour un système multitâche coopératif ne pouvant pas fonctionner nativement en mode préemptif (pour des raisons de compatibilité avec les logiciels plus anciens), l'ordonnanceur de Windows a donc été conçu de manière à désactiver le mode préemptif lors de l'exécution de code "coopératif". De cette manière, tout exécutable - bibliothèque conçu pour Windows 3.1 fonctionne sous Windows 95 en mode coopératif et tout exécutable - bibliothèque conçu exclusivement pour Windows 95 - NT fonctionne en mode préemptif.
Les effets de ce multitâche hybride sont observables lorsque l'on utilise des exécutables - bibliothèques compilés d'un côté pour Windows 3.X (Win16), et d'un autre côté pour Windows 95-NT (Win32). Prenons par exemple le cas d'un exécutable dont le code a été conçu de manière à rester bloqué dans une boucle sans fin. Si la boucle sans fin est placée dans un exécutable Win32 et que le programme est lancé, Windows reste réactif et il est toujours possible d'utiliser d'autres programmes en parallèle (la boucle sans fin est donc préemptée par le système). Si la boucle sans fin est placée dans un exécutable Win16 et que le programme est lancé, Windows reste "figé" ainsi que tous les programmes précédemment lancés, et seule une action ctrl+alt+suppr permettra de "récupérer" le système. Dans ce mode, le système ne préempte plus et attend que le programme rende la main. Plusieurs programmes Win32 font appel à des bibliothèques Win16 lors de leur fonctionnement, rendant leur fonctionnement complètement "hybrides" : préemptifs lors de l'exécution de code Win32 et coopératifs lors de l'exécution de la bibliothèque Win16, le système s'assurant de passer d'un mode à l'autre de manière transparente.
Cette particularité ne s'applique pas à Windows NT-2000-XP qui utilisent un système de virtualisation (Win16 on Win32 - WoW) pour effectuer les mêmes opérations.

Comparaison
Le multitâche préemptif est plus robuste que le multitâche coopératif : une tâche ne peut bloquer l'ensemble du système. Le système d'exploitation peut aussi utiliser plus efficacement les ressources disponibles, par exemple si des données sont disponibles via un périphérique d'entrée, le processus devant traiter ces données peut être immédiatement activé. De plus, une tâche en attente de données ne consommera pas de temps processeur avant que ses données ne soient réellement disponibles.
Bien que, au départ, le multitâche ait été conçu pour permettre à plusieurs utilisateurs d'utiliser le même ordinateur, il est apparu très rapidement qu'il était très pratique même pour un seul utilisateur. Utiliser son traitement de texte favori tout en naviguant sur le Web est de nos jours une caractéristique incontournable.
Une autre utilité du multitâche provient du fait qu'il est plus facile de concevoir et d'écrire plusieurs programmes simples, plutôt qu'un seul programme capable de tout faire, puis de les faire coopérer pour effectuer les tâches nécessaires.
Les algorithmes implémentant le multitâche ont été raffinés au cours du temps. Les systèmes modernes peuvent gérer des processus avec des priorités différentes ainsi que des ordinateurs comportant de un à quelques centaines de processeurs.
La technologie des processus légers (en anglais : threads) a été permise grâce à la présence de gestionnaires de mémoire évolués. Les processus légers partagent tout ou partie de la mémoire d'un processus existant. Ce partage permet, entre autres, une commutation de contexte plus rapide et un partage de données plus efficace entre les processus légers. En contrepartie, de tels programmes peuvent être plus complexes et peuvent se montrer difficiles à mettre au point.
Une autre innovation clé a été l'introduction des niveaux de privilèges : les processus possédant un niveau de privilège bas ne peuvent pas effectuer certaines opérations, par exemple écrire sur des portions de mémoire vitales pour la sécurité du système.
Si un tel processus effectue une opération interdite, le programme est interrompu et un programme superviseur (souvent le système d'exploitation) préempte le processus en cours, puis l'arrête définitivement. Cette technique permet de créer des machines virtuelles où le système "réel" émule le fonctionnement d'une ou plusieurs machines virtuelles, par exemple afin d'accroître la sécurité (une machine virtuelle ne peut pas interférer avec une autre machine virtuelle).

Voir aussi: Synchronisation (multitâches); Temps partagé; Taux de multiprogrammation; Système temps réel; Programmation concurrente; Grafcet. Portail de l'informatique.