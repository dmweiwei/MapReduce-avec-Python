L'HyperText Transfer Protocol, plus connu sous l'abréviation HTTP - littéralement "protocole de transfert hypertexte" - est un protocole de communication client-serveur développé pour le World Wide Web. HTTPS (avec S pour secured, soit "sécurisé") est la variante du HTTP sécurisée par l'usage des protocoles SSL ou TLS.
HTTP est un protocole de la couche application. Il peut fonctionner sur n'importe quelle connexion fiable, dans les faits on utilise le protocole TCP comme couche de transport. Un serveur HTTP utilise alors par défaut le port 80 (443 pour HTTPS).
Les clients HTTP les plus connus sont les navigateurs Web permettant à un utilisateur d'accéder à un serveur contenant les données. Il existe aussi des systèmes pour récupérer automatiquement le contenu d'un site tel que les aspirateurs de site Web ou les robots d'indexation.

Historique
HTTP a été inventé par Tim Berners-Lee avec les adresses Web et le langage HTML pour créer le World Wide Web. À cette époque, le File Transfer Protocol (FTP) était déjà disponible pour transférer des fichiers, mais il ne supportait pas la notion de format de données telle qu'introduite par Multipurpose Internet Mail Extensions (MIME). La première version de HTTP était très élémentaire, mais prévoyait déjà le support d'en-têtes MIME pour décrire les données transmises. Cette première version reste encore partiellement utilisable de nos jours, connue sous le nom de HTTP-0.9.
En mai 1996, HTTP-1.0 voit le jour et est décrit dans la RFC 1945. Cette version supporte les serveurs HTTP virtuels, la gestion de cache et l'identification.
En janvier 1997, HTTP-1.1 devient finalement standard de l'IETF. Il est décrit dans la RFC 2068 de l'IETF, puis dans la RFC 2616 en juin 1999. Cette version ajoute le support du transfert en pipeline (ou pipelinage) et la négociation de type de contenu (format de données, langue).
En mars 2012, les travaux à propos de HTTP-2.0 démarrent à l'IETF adoptant SPDY comme matériel de départ.
En février 2014, la spécification de HTTP 1.1 a été republiée. Elle a été éclatée en plusieurs RFC et corrigée pour toutes ses imprécisions, RFC 7230 à RFC 7237.

Implémentation

Méthodes
Capture d'écran d'une requête GET et de sa réponse.
Dans le protocole HTTP, une méthode est une commande spécifiant un type de requête, c'est-à-dire qu'elle demande au serveur d'effectuer une action. En général l'action concerne une ressource identifiée par l'URL qui suit le nom de la méthode.
Dans l'illustration ci-contre, une requête GET est envoyée pour récupérer la page d'accueil du site web www.perdu.com :
Il existe de nombreuses méthodes, les plus courantes étant GET, HEAD et POST : GET: C'est la méthode la plus courante pour demander une ressource. Une requête GET est sans effet sur la ressource, il doit être possible de répéter la requête sans effet. HEAD: Cette méthode ne demande que des informations sur la ressource, sans demander la ressource elle-même. POST: Cette méthode est utilisée pour transmettre des données en vue d'un traitement à une ressource (le plus souvent depuis un formulaire HTML). L'URI fourni est l'URI d'une ressource à laquelle s'appliqueront les données envoyées. Le résultat peut être la création de nouvelles ressources ou la modification de ressources existantes. À cause de la mauvaise implémentation des méthodes HTTP (pour Ajax) par certains navigateurs (et la norme HTML qui ne supporte que les méthodes GET et POST pour les formulaires), cette méthode est souvent utilisée en remplacement de la requête PUT, qui devrait être utilisée pour la mise à jour de ressources. OPTIONS: Cette méthode permet d'obtenir les options de communication d'une ressource ou du serveur en général. CONNECT: Cette méthode permet d'utiliser un proxy comme un tunnel de communication. TRACE: Cette méthode demande au serveur de retourner ce qu'il a reçu, dans le but de tester et effectuer un diagnostic sur la connexion. PUT: Cette méthode permet de remplacer ou d'ajouter une ressource sur le serveur. L'URI fourni est celui de la ressource en question. PATCH: Cette méthode permet, contrairement à PUT, de faire une modification partielle d'une ressource. DELETE: Cette méthode permet de supprimer une ressource du serveur.
Ces 3 dernières méthodes nécessitent généralement un accès privilégié.
Certains serveurs autorisent d'autres méthodes de gestion de leurs ressources (par exemple WebDAV).

Du client au serveur
La liaison entre le client et le serveur n'est pas toujours directe, il peut exister des machines intermédiaires servant de relais : Un proxy (ou serveur mandataire) peut modifier les réponses et requêtes qu'il reçoit et peut gérer un cache des ressources demandées.; Une passerelle (ou gateway) est un intermédiaire modifiant le protocole utilisé.; Un tunnel transmet les requêtes et les réponses sans aucune modification, ni mise en cache.

Identification
HTTP permet l'identification du visiteur par transmission d'un nom et d'un mot de passe. Il existe 2 modes d'identification : Basic et Digest (RFC 2617). Le premier mode transmet le mot de passe en clair, et ne doit donc être utilisé qu'avec le protocole HTTPS. Le deuxième mode permet une identification sans transmettre le mot de passe en clair. L'identification est cependant souvent effectuée par une couche applicative supérieure à HTTP.

Liste de serveurs HTTP: C : Apache, Zeus Web Server, nginx, lighttpd, Cherokee, Hiawatha Webserver; ASP-ASP.Net(C, VB.net) : IIS; Java : Tomcat, Jetty, GlassFish, JBoss, JOnAS, Vert.x; Python : Zope; Pike : Caudium; Ruby : WEBrick, Mongrel, Thin; Erlang : Yaws; Javascript : Node.js; Autres : (en) Comparison of web servers.

Versions

HTTP 0.9
Au début du World Wide Web, il était prévu d'ajouter au protocole HTTP des capacités de négociation de contenu, en s'inspirant notamment de MIME. En attendant, le protocole HTTP 0.9 était extrêmement simple. 1) connexion du client HTTP; 2) envoi d'une requête de méthode GET; 3) réponse du serveur HTTP; 4) le serveur ferme la connexion pour signaler la fin de la réponse.
Requête :
La méthode GET est la seule possible. Le serveur reconnaît qu'il a affaire à une requête HTTP 0.9 au fait que la version n'est pas précisée à la suite de l'URI.
Réponse :
Pour répondre à une requête HTTP 0.9, le serveur envoie directement le contenu de la réponse, sans méta-données. Il ne doit jamais se comporter ainsi pour les requêtes HTTP de version supérieure.
Inutile de chercher les versions inférieures à 0.9 du protocole HTTP : elles n'existent pas, car HTTP 0.9 n'avait initialement pas de numéro de version. Il a fallu lui en attribuer un quand HTTP 1.0 est arrivé.

HTTP 1.0
Le protocole HTTP 1.0, décrit dans la RFC 1945, prévoit l'utilisation d'en-têtes spécifiés dans la RFC 822. La gestion de la connexion reste identique à HTTP 0.9 : le client établit la connexion, envoie une requête, le serveur répond et ferme immédiatement la connexion.
Une requête HTTP présente le format suivant :
Les réponses HTTP présentent le format suivant :
Requête :
La version du protocole HTTP est précisée à la suite de l'URI. La requête doit être terminée par un double retour à la ligne (CRLFCRLF). HTTP 1.0 supporte aussi les méthodes HEAD et POST. On constate l'usage d'en-têtes inspirés de MIME pour transférer les méta-données : Host: Permet de préciser le site web concerné par la requête, ce qui est nécessaire pour un serveur hébergeant plusieurs sites à la même adresse IP (name based virtual host, hôte virtuel basé sur le nom). C'est le seul en-tête réellement important. Referer: Indique l'URI du document qui a donné un lien sur la ressource demandée. Cet en-tête permet aux webmasters d'observer d'où viennent les visiteurs. User-Agent: Indique le logiciel utilisé pour se connecter. Il s'agit généralement d'un navigateur Web ou d'un robot d'indexation.
Réponse :
La première ligne donne le code de statut HTTP (200 dans ce cas). Date: Moment auquel le message est généré. Server: Indique quel modèle de serveur HTTP répond à la requête. Content-Type: Indique le type MIME de la ressource. Content-Length: Indique la taille en octets de la ressource. Expires: Indique le moment après lequel la ressource devrait être considérée obsolète ; permet aux navigateurs Web de déterminer jusqu'à quand garder la ressource en mémoire cache. Last-Modified: Indique la date de dernière modification de la ressource demandée.
HTTP 1.1
Le protocole HTTP 1.1 est décrit par le RFC 2616 qui rend le RFC 2068 obsolète. La différence avec HTTP 1.0 est une meilleure gestion du cache. L'en-tête Host devient obligatoire dans les requêtes.
Les soucis majeurs des deux premières versions du protocole HTTP sont d'une part le nombre important de connexions lors du chargement d'une page complexe (contenant beaucoup d'images ou d'animations) et d'autre part le temps d'ouverture d'une connexion entre client et serveur (l'établissement d'une connexion TCP prend un temps triple de la latence entre client et serveur). Des expérimentations de connexions persistantes ont cependant été effectuées avec HTTP 1.0 (notamment par l'emploi de l'en-tête Connection: Keep-Alive), mais cela n'a été définitivement mis au point qu'avec HTTP 1.1.
Par défaut, HTTP 1.1 utilise des connexions persistantes, autrement dit la connexion n'est pas immédiatement fermée après une requête, mais reste disponible pour une nouvelle requête. On appelle souvent cette fonctionnalité keep-alive. Il est aussi permis à un client HTTP d'envoyer plusieurs requêtes sur la même connexion sans attendre les réponses. On appelle cette fonctionnalité pipelining. La persistance des connexions permet d'accélérer le chargement de pages contenant plusieurs ressources, tout en diminuant la charge du réseau.
La gestion de la persistance d'une connexion est gérée par l'en-tête Connection.
HTTP 1.1 supporte la négociation de contenu. Un client HTTP 1.1 peut accompagner la requête pour une ressource d'en-têtes indiquant quels sont les langues et formats de données préférés. Il s'agit des en-têtes dont le nom commence par Accept-.
Les en-têtes supplémentaires supportés par HTTP 1.1 sont : Connection: Cet en-tête peut être envoyé par le client ou le serveur et contient une liste de noms spécifiant les options à utiliser avec la connexion actuelle. Si une option possède des paramètres ceux-ci sont spécifiés par l'en-tête portant le même nom que l'option (Keep-Alive par exemple, pour spécifier le nombre maximum de requêtes par connexion). Le nom close est réservé pour spécifier que la connexion doit être fermée après traitement de la requête en cours. Accept: Cet en-tête liste les types MIME de contenu acceptés par le client. Le caractère étoile - peut servir à spécifier tous les types - sous-types. Accept-Charset: Spécifie les encodages de caractères acceptés. Accept-Language: Spécifie les langues acceptées.
L'ordre de préférence de chaque option (type, encodage ou langue) est spécifié par le paramètre optionnel q contenant une valeur décimale entre 0 (inacceptable) et 1 (acceptable) inclus (3 décimales maximum après la virgule), valant 1 par défaut.
Le support des connexions persistantes doit également fonctionner dans les cas où la taille de la ressource n'est pas connue d'avance (ressource générée dynamiquement par le serveur, flux externe au serveur...).
Pour cela, l'encodage de transfert nommé chunked permet de transmettre la ressource par morceaux consécutifs en précédant chacun par une ligne de texte donnant la taille de celui-ci en hexadécimal. Le transfert se termine alors par un morceau de taille nulle, où des en-têtes finaux peuvent être envoyés.
Les en-têtes supplémentaires liés à cet encodage de transfert sont : Transfer-Encoding: Spécifie l'encodage de transfert. La seule valeur définie par la spécification RFC 2616 est chunked. Trailer: Liste tous les en-têtes figurant après le dernier morceau transféré. TE: Envoyé par le client pour spécifier les encodages de contenu supportés (Content-Encoding, ne pas confondre avec Transfer-Encoding car chunked est obligatoirement supporté par les clients et serveurs implémentant le standard HTTP-1.1), et spécifie si le client supporte l'en-tête Trailer en ajoutant trailers à la liste.
HTTP 1.1 bis
RFC 2616 comprenait de nombreuses imprécisions. Le groupe de travail HTTP a pris quelques années afin de clarifier la spécification sans en modifier la sémantique tel que préconisé dans la charte de fonctionnement du groupe pour ce travail. En juin 2014, 8 nouveaux documents ont été publiés qui rendent obsolètes la RFC 2616 : RFC 7230(4) Hypertext Transfer Protocol (HTTP-1.1): Message Syntax and Routing (Standard proposé); RFC 7231(8) Hypertext Transfer Protocol (HTTP-1.1): Semantics and Content (Standard proposé); RFC 7232(9) Hypertext Transfer Protocol (HTTP-1.1): Conditional Requests (Standard proposé); RFC 7233(10) Hypertext Transfer Protocol (HTTP-1.1): Range Requests (Standard proposé); RFC 7234(11) Hypertext Transfer Protocol (HTTP-1.1): Caching (Standard proposé); RFC 7235(12) Hypertext Transfer Protocol (HTTP-1.1): Authentication (Standard proposé); RFC 7236(13) Hypertext Transfer Protocol (HTTP-1.1): Authentication Scheme Registrations (Information); RFC 7237(5) Hypertext Transfer Protocol (HTTP-1.1): Method Registrations (Information).

HTTP-2
Une nouvelle version d'HTTP, HTTP-2, a été développée au sein du groupe de travail "Hypertext Transfer Protocol Bis" (httpbis) de l'Internet Engineering Task Force, et approuvée comme RFC standard le 18 février 2015. Le développement d'HTTP-2 a débuté à la suite de la création du protocole SPDY proposé par Google afin de réduire le temps de chargement des pages Web. Le groupe de travail httpbis s'était initialement interdit de proposer une nouvelle version d'HTTP, concentrant son activité sur la clarification des spécifications d'HTTP 1.1. Considérant l'arrivée de SPDY et son adoption rapide sur le Web, avec notamment des implémentations dans deux des principaux navigateurs Web, Google Chrome et Mozilla Firefox, Mark Nottingham, "chair" d'httpbis, a émis l'opinion qu'il était temps d'envisager HTTP-2 et proposé d'amender la charte d'httpbis en ce sens, initiant de fait le développement du nouveau protocole.
SPDY constituait une option naturelle pour servir de base à HTTP-2. Deux autres propositions concurrentes ont été ensuite transmises à l'IETF : le protocole "HTTP Speed+Mobility" par Microsoft et une proposition de mise à jour d'HTTP ("Network-Friendly HTTP Upgrade"). En juillet 2012, httpbis a publié un appel à expression d'intérêt ("Call for Expression of Interest") afin de recueillir l'avis d'acteurs du Web sur les propositions. Parmi les réponses obtenues figure celle de Facebook qui a signifié sa préférence pour SPDY. En novembre 2012, l'IETF a publié le premier draft d'HTTP-2, qui est une copie directe de SPDY.
Après plus de 2 ans de discussions, la RFC est approuvée en février 2015 par le groupe de pilotage de l'IETF, et est publiée en mai 2015.
Le module permettant la prise en charge du protocole HTTP-2 dans le serveur Web Apache est disponible depuis la version 2.4.17 du logiciel.

Voir aussi

Articles connexes: Format ouvert; Interopérabilité; Liste des codes HTTP; Navigateur Web; Pipelining HTTP; Protocole de communication; Serveur HTTP; World Wide Web; HTTPS.