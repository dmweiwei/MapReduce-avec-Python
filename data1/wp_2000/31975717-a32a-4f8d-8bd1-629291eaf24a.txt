Transport Layer Security (TLS), et son prédécesseur Secure Sockets Layer (SSL), sont des protocoles de sécurisation des échanges sur Internet. Le protocole SSL a été développé à l'origine par Netscape. L'IETF en a poursuivi le développement en le rebaptisant Transport Layer Security (TLS). On parle parfois de SSL-TLS pour désigner indifféremment SSL ou TLS.
TLS (ou SSL) fonctionne suivant un mode client-serveur. Il permet de satisfaire aux objectifs de sécurité suivants : l'authentification du serveur ;; la confidentialité des données échangées (ou session chiffrée) ;; l'intégrité des données échangées ;; de manière optionnelle, l'authentification du client (mais dans la réalité celle-ci est souvent assurée par le serveur).
Le protocole est très largement utilisé, sa mise en oeuvre est facilitée par le fait que les protocoles de la couche application, comme HTTP, n'ont pas à être profondément modifiés pour utiliser une connexion sécurisée, mais seulement implémentés au-dessus de SSL-TLS, ce qui pour HTTP a donné le protocole HTTPS.
Un groupe de travail spécial de l'IETF a permis la création du TLS et de son équivalent en mode UDP, le DTLS. Depuis qu'il est repris par l'IETF, le protocole TLS a connu trois versions, TLS v1.0 en 1999, TLS v1.1 en 2006 et TLS v1.2 en 2008. Un premier brouillon de TLS v1.3 est sorti en 2014.

Présentation
Au fur et à mesure qu'Internet se développait, de plus en plus de sociétés commerciales se mirent à proposer des achats en ligne pour les particuliers. L'offre se mit à croître régulièrement, mais le chiffre d'affaires dégagé par le commerce électronique restait modeste tant que les clients n'avaient pas une confiance suffisante dans le paiement par carte bancaire. Une des façons de sécuriser ce paiement fut d'utiliser des protocoles d'authentification et de chiffrement tels que SSL. La session chiffrée est utilisée pour empêcher un tiers d'intercepter des données sensibles transitant par le réseau : numéro de carte lors d'un paiement par carte bancaire, mot de passe lorsque l'utilisateur s'identifie sur un site...
Avec un système SSL, la sécurité a été sensiblement améliorée et les risques pour le client grandement réduits, comparés à l'époque où le paiement par internet était encore une technologie émergente. Bien que, comme tout système de chiffrement, le SSL-TLS ne pourra jamais être totalement infaillible, le grand nombre de banques et de sites de commerce électronique l'utilisant pour protéger les transactions de leurs clients peut être considéré comme un gage de sa résistance aux attaques malveillantes.
En 2009, TLS est utilisé par la plupart des navigateurs Web. L'internaute peut reconnaître qu'une transaction est chiffrée à plusieurs signes : l'URL dans la barre d'adresse commence par https et non http (https:--...) ;; affichage d'une clé ou d'un cadenas, dont l'emplacement varie selon le navigateur : généralement à gauche de la barre d'adresse mais aussi dans la barre inférieure de la fenêtre ;; les navigateurs peuvent ajouter d'autres signes, comme le passage en jaune de la barre d'adresse (cas de Firefox sur d'anciennes versions).

Historique

Protocole SSL
La première version de SSL parue, la SSL 2.0, possédait un certain nombre de défauts de sécurité, parmi lesquels la possibilité de forcer l'utilisation d'algorithmes de chiffrement plus faibles, ou bien une absence de protection pour la prise de contact et la possibilité pour un attaquant d'exécuter des attaques par troncature. Les protocoles PCT 1.0, puis SSL 3.0, furent développés pour résoudre la majeure partie de ces problèmes, le second devenant rapidement le protocole le plus populaire pour sécuriser les échanges sur Internet. 1994 : SSL 1.0. Cette première spécification du protocole développé par Netscape resta théorique et ne fut jamais mise en oeuvre.; Février 1995 : publication de la norme SSL 2.0, première version de SSL réellement utilisée. Elle fut également la première implémentation de SSL bannie, en mars 2011 (RFC 6176).; Novembre 1996 : SSL 3.0, la dernière version de SSL, qui inspirera son successeur TLS. Ses spécifications sont rééditées en août 2008 dans la RFC 6101. Le protocole est banni en 2014, à la suite de la publication de la faille POODLE, ce bannissement est définitivement ratifié en juin 2015 (RFC 7568).

Protocole TLS
Le protocole TLS n'est pas structurellement différent de la version 3 de SSL, mais des modifications dans l'utilisation des fonctions de hachage font que les deux protocoles ne sont pas directement interopérables. Cependant TLS, comme SSLv3, intègre un mécanisme de compatibilité ascendante avec les versions précédentes, c'est-à-dire qu'au début de la phase de négociation, le client et le serveur négocient la "meilleure" version du protocole disponible par tous deux. Pour des raisons de sécurité, détaillées dans la RFC 6176 parue en 2011, la compatibilité de TLS avec la version 2 de SSL est abandonnée.
La génération des clés symétriques est un peu plus sécurisée dans TLS que dans SSLv3 dans la mesure où aucune étape de l'algorithme ne repose uniquement sur MD5 pour lequel sont apparues des faiblesses en cryptanalyse. Janvier 1999 (RFC 2246) : Publication de la norme TLS 1.0. TLS est le protocole développé par l'IETF pour succéder au SSL. Plusieurs améliorations lui sont apportées par la suite : Octobre 1999 (RFC 2712) : Ajout du protocole Kerberos à TLS ;; Mai 2000 (RFC 2817 et RFC 2818) : Passage à TLS lors d'une session HTTP 1.1 ;; Juin 2002 (RFC 3268) : Support du système de chiffrement AES par TLS.; Octobre 1999 (RFC 2712) : Ajout du protocole Kerberos à TLS ;; Mai 2000 (RFC 2817 et RFC 2818) : Passage à TLS lors d'une session HTTP 1.1 ;; Juin 2002 (RFC 3268) : Support du système de chiffrement AES par TLS.; Avril 2006 (RFC 4346) : Publication de la norme TLS 1.1.; Août 2008 (RFC 5246) : Publication de la norme TLS 1.2.; Mars 2011 (RFC 6176) : Abandon de la compatibilité avec SSLv2 pour toutes les versions de TLS.; Avril 2014 : 1er brouillon pour TLS 1.3.; Juin 2015 (RFC 7568) : Abandon de la compatibilité avec SSLv2 et SSLv3.; Octobre 2015 : Nouveau brouillon de TLS 1.3.

Mise en oeuvre de TLS

Support par les navigateurs
La plupart des navigateurs web gèrent TLS 1.0. Les navigateurs supportant par défaut la dernière version TLS 1.1 et TLS 1.2 sont : Apple Safari 7 et suivants ;; Google Chrome et Chromium 30 et suivants ;; Microsoft Internet Explorer 11 et suivants ;; Mozilla Firefox 27 et suivants ;; Opera 17 et suivants ;; Microsoft Edge.
HTTPS Everywhere est une extension pour navigateur web qui permet d'étendre l'usage du SSL-TLS sur certains sites. Elle active le SSL sur les pages où ce protocole est normalement désactivé. Ceci ne peut évidemment fonctionner que si le site en question supporte déjà le SSL. L'extension est maintenue conjointement par le projet Tor et l'EFF depuis 2010.

Authentification par certificat numérique
Dans la majorité des cas, l'utilisateur authentifie le serveur TLS sur lequel il se connecte. Cette authentification est réalisée par l'utilisation d'un certificat numérique X.509 délivré par une autorité de certification (AC). Des applications web peuvent utiliser l'authentification du poste client en exploitant TLS. Il est alors possible d'offrir une authentification mutuelle entre le client et le serveur. Le certificat client peut être stocké au format logiciel sur le poste client ou fourni par un dispositif matériel (carte à puce, token USB). Cette solution permet d'offrir des mécanismes d'authentification forte.

Principe de fonctionnement dans les navigateurs web
Message d'avertissement du navigateur web Firefox s'affichant si le certificat envoyé par le serveur est auto-signé.
Lorsqu'un utilisateur se connecte à un site web qui utilise TLS, les étapes suivantes ont lieu : 1) le navigateur du client envoie au serveur une demande de mise en place de connexion sécurisée par TLS.; 2) Le serveur envoie au client son certificat (voir l'article concerné pour plus de détails) : celui-ci contient sa clé publique, ses informations (nom de la société, adresse postale, pays, e-mail de contact...) ainsi qu'une signature numérique sous forme de texte chiffré.; 3) Le navigateur du client tente de déchiffrer la signature numérique du certificat du serveur en utilisant les clés publiques contenues dans les certificats des autorités de certifications (AC) intégrés par défaut dans le navigateur. 1) Si l'une d'entre elles fonctionne, le navigateur web en déduit le nom de l'autorité de certification qui a signé le certificat envoyé par le serveur. Il vérifie que celui-ci n'est pas expiré puis envoie une demande OCSP à cette autorité pour vérifier que le certificat du serveur n'a pas été révoqué.; 2) Si aucune d'entre elles ne fonctionne, le navigateur web tente de déchiffrer la signature numérique du certificat du serveur à l'aide de la clé publique contenue dans celui-ci. 1) En cas de réussite, cela signifie que le serveur web a lui-même signé son certificat. Un message d'avertissement s'affiche alors sur le navigateur web, prévenant l'utilisateur que l'identité du serveur n'a pas été vérifiée par une autorité de certification et qu'il peut donc s'agir potentiellement d'un site frauduleux.; 2) En cas d'échec, le certificat est invalide, la connexion ne peut pas aboutir.; 3) En cas de réussite, cela signifie que le serveur web a lui-même signé son certificat. Un message d'avertissement s'affiche alors sur le navigateur web, prévenant l'utilisateur que l'identité du serveur n'a pas été vérifiée par une autorité de certification et qu'il peut donc s'agir potentiellement d'un site frauduleux.; 4) En cas d'échec, le certificat est invalide, la connexion ne peut pas aboutir.; 4) Si l'une d'entre elles fonctionne, le navigateur web en déduit le nom de l'autorité de certification qui a signé le certificat envoyé par le serveur. Il vérifie que celui-ci n'est pas expiré puis envoie une demande OCSP à cette autorité pour vérifier que le certificat du serveur n'a pas été révoqué.; 5) Si aucune d'entre elles ne fonctionne, le navigateur web tente de déchiffrer la signature numérique du certificat du serveur à l'aide de la clé publique contenue dans celui-ci. 1) En cas de réussite, cela signifie que le serveur web a lui-même signé son certificat. Un message d'avertissement s'affiche alors sur le navigateur web, prévenant l'utilisateur que l'identité du serveur n'a pas été vérifiée par une autorité de certification et qu'il peut donc s'agir potentiellement d'un site frauduleux.; 2) En cas d'échec, le certificat est invalide, la connexion ne peut pas aboutir.; 6) En cas de réussite, cela signifie que le serveur web a lui-même signé son certificat. Un message d'avertissement s'affiche alors sur le navigateur web, prévenant l'utilisateur que l'identité du serveur n'a pas été vérifiée par une autorité de certification et qu'il peut donc s'agir potentiellement d'un site frauduleux.; 7) En cas d'échec, le certificat est invalide, la connexion ne peut pas aboutir.; 8) Le navigateur du client génère une clé de chiffrement symétrique (à la différence des clés privés et publiques utilisés par les certificats qui sont asymétriques), appelée clé de session, qu'il chiffre à l'aide de la clé publique contenue dans le certificat du serveur puis transmet cette clé de session au serveur.; 9) Le serveur déchiffre la clé de session envoyée par le client grâce à sa clé privée.; 10) Le client et le serveur commencent à s'échanger des données en chiffrant celles-ci avec la clé de session qu'ils ont en commun. On considère à partir de ce moment que la connexion TLS est alors établie entre le client et le serveur.; 11) Une fois la connexion terminée (déconnexion volontaire de l'utilisateur ou si durée d'inactivité trop élevée), le serveur révoque la clé de session.
Optionnel : si le serveur nécessite également que le client s'authentifie, le client lui envoie son propre certificat en même temps que la clé de session. Le serveur procède alors comme détaillé au point n3 pour vérifier que le certificat du client est valide.

Attaques
En 2001, Serge Vaudenay a découvert une attaque par canal auxiliaire contre SSL. À la suite de la mise à jour du standard, cette attaque est maintenant totalement dépassée et ne peut plus être utilisée. Cette attaque profitait d'une mauvaise implémentation du remplissage qui était utilisé lorsque les entrées avaient une taille variable. Le mode de chiffrement CBC (cipher block chaining) consiste à diviser les données en plusieurs blocs de même taille et à les chiffrer de manière chaînée (le résultat précédent est utilisé lors du chiffrement suivant). L'attaque de Vaudenay utilisait les temps de réponse des serveurs en cas d'erreurs lors du remplissage. Avec un peu de chance, il était possible de découvrir les dernières données qui avaient été envoyées et de les récupérer. L'attaque était toutefois inopérante avec un chiffrement de type RC4 et n'était valable que sous certaines conditions. Elle a malgré tout été utilisée avec succès contre certains "webmails" qui envoyaient plusieurs fois les mêmes données.
En mars 2014, une vulnérabilité logicielle fut découverte dans la bibliothèque OpenSSL : Heartbleed, introduite par erreur dans une mise à jour d'OpenSSL réalisée deux ans plus tôt. Cette faille a été largement médiatisée, y compris dans les médias généralistes, comme l'avait été notamment le ver I love you en 2000.
Le 15 octobre 2014, une équipe de recherche chez Google a identifié une faille dans la conception de SSLv3 permettant de déchiffrer le contenu. Cette attaque a été nommée POODLE pour Padding Oracle On Downgraded Legacy. Elle est présente uniquement dans SSLv3.
Le 2 mars 2016, les chercheurs détaillent la faille baptisée DROWN. Elle consiste à utiliser l'ancienne version SSLv2 afin de déchiffrer la technologie TLSv1.2.

Spécifications techniques
modèle OSI pile de protocoles 7 - couche application HTTP, SMTP, FTP, SSH, IRC, SNMP, SIP... 6 - couche de présentation 5 - couche de session TLS, SSL,SSH-user, NetBIOS 4 - couche de transport TLS, SSL,TCP, UDP, SCTP, RTP, DCCP... 3 - couche réseau IPv4, IPv6, ARP, IPX... 2 - couche de liaison Ethernet, 802.11 WiFi, Token ring, FDDI,.. 1 - couche physique Câble, fibre optique, ondes radio...
Dans la pile de protocole TCP-IP, SSL se situe entre la couche application (comme HTTP, FTP, SMTP, etc.) et la couche transport TCP. Son utilisation la plus commune reste cependant en dessous de HTTP. Le protocole SSL est implémenté par la couche session de la pile, ce qui a deux conséquences : pour toute application existante utilisant TCP, il peut exister une application utilisant SSL. Par exemple, l'application HTTPS correspond à HTTP au-dessus de SSL ;; une application SSL se voit attribuer un nouveau numéro de port par l'IANA. Par exemple HTTPS est associé au port 443. Dans certains cas, le même port est utilisé avec et sans SSL. Dans ce cas, la connexion est initiée en mode non chiffré. Le tunnel est ensuite mis en place au moyen du mécanisme StartTLS. C'est le cas, par exemple, des protocoles IMAP, SMTP ou LDAP.
La sécurité est réalisée d'une part par un chiffrement asymétrique, comme le chiffrement RSA, qui permet, après authentification de la clé publique du serveur, la constitution d'un secret partagé entre le client et le serveur, d'autre part par un chiffrement symétrique (beaucoup plus rapide que les chiffrements asymétriques), comme l'AES, qui est utilisé dans la phase d'échange de données, les clés de chiffrement symétrique étant calculées à partir du secret partagé. Une fonction de hachage, comme SHA-1, est également utilisée, entre autres, pour assurer l'intégrité et l'authentification des données (via par exemple HMAC).

Voir aussi

Articles connexes: SET : protocole destiné spécialement à sécuriser les transactions Internet de paiement par carte bancaire.; Chiffrement; Authentification; Authentification forte; Protocole de vérification en ligne de certificat; Port hopping; Pour les implémentations, voir : OpenSSL ;; GnuTLS ;; JSSE pour Java.; OpenSSL ;; GnuTLS ;; JSSE pour Java.; HTTP Strict Transport Security. Comment générer une clé publique. Portail de la sécurité informatique; Portail des télécommunications.