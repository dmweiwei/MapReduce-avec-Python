En mathématiques, et plus précisément en informatique théorique, le problème P - NP est une conjecture considérée par de nombreux chercheurs comme une des plus importantes conjectures du domaine, et même des mathématiques en général. L'Institut de mathématiques Clay a inclus ce problème dans sa liste des sept problèmes du prix du millénaire, et offre à ce titre un million de dollars à quiconque sera en mesure de démontrer P - NP ou P NP ou de démontrer que ce n'est pas démontrable. Ce problème est également le troisième problème de Smale.
Très schématiquement, il s'agit de déterminer si le fait de pouvoir vérifier rapidement une solution à un problème implique de pouvoir la trouver rapidement ; ou encore, si ce que nous pouvons trouver rapidement lorsque nous avons de la chance peut être trouvé aussi vite par un calcul intelligent.
Plus précisément, il s'agit de savoir si la classe de complexité P des problèmes de décision admettant un algorithme de résolution s'exécutant en temps polynomial sur une machine de Turing est équivalente à la classe de complexité NP des problèmes de décision dont la vérification du résultat, une fois celui-ci connu, demande un temps polynomial. Un algorithme qui demande un temps d'exécution polynomial est généralement considéré comme "rapide" (par rapport à un temps d'exécution exponentiel par exemple).
À condition que le degré du polynôme issu du caractère polynomial de l'algorithme soit raisonnable, les conséquences de P - NP pourraient être considérables dans de nombreux domaines : cryptologie, informatique, mathématiques, ingénierie, économie. S'il était prouvé que P - NP, alors la résolution de tous les autres problèmes posés par l'Institut Clay deviendrait évidente. S'il était au contraire avéré que P NP, cela signifierait qu'une large classe de problèmes seraient presque sûrement définitivement hors d'atteinte du calcul dans un temps raisonnable (ou nécessiteraient le développement d'architectures différentes de celles des machines de Turing).

Complexité des algorithmes, classes P et NP

Importance et implications de P-NP
Un des aspects essentiels de ce problème provient du fait qu'il existe une classe de problèmes très importants dits "NP-complets" qui est la sous-classe de NP dont les problèmes sont au moins aussi durs que tous les problèmes de NP, autrement dit les problèmes les plus durs de NP. Ils sont importants à double titre : d'une part, ils possèdent souvent une importance intrinsèque (de nombreux problèmes fondamentaux dans plusieurs domaines étant NP-complets) et, d'autre part, par définition de la NP-complétude, si on trouve une solution en temps polynomial à l'un de ces problèmes, alors cette solution peut être utilisée pour résoudre tous les problèmes NP-complets, et NP en général en temps polynomial. Le théorème de Cook montre que le problème SAT est NP-complet, ce résultat a ensuite été largement réutilisé pour établir une liste de problèmes NP-complets.
Les problèmes NP-complets concernent un grand nombre de domaines différents : la biologie, avec par exemple l'algorithme de détermination de la séquence d'ADN qui correspond le mieux à un ensemble de fragments, ou le calcul de solution optimales en économie (équilibres de Nash), ou dans les processus de fabrication ou de transport.
Trouver un algorithme qui résout un problème NP-complet, comme le problème du voyageur de commerce, en temps polynomial suffirait à démontrer que P-NP, ce serait alors toute une série de problèmes très importants qui se trouveraient résolus (et, dans un même temps, les systèmes de cryptographie à clé publique seraient cassés). Même sans exhiber un algorithme, une preuve pourrait donner des indices précieux pour construire un tel algorithme, ou pour le moins en relancer sérieusement la recherche, car on le saurait alors possible avec certitude. L'existence de cet algorithme remettrait en question l'utilisation des systèmes de cryptographie à clé publique, qui servent notamment pour la sécurisation des transactions bancaires. En effet, casser ces systèmes revient à résoudre un problème NP (intuitivement, c'est facile si on connaît la clé privée). La sécurité repose sur l'assertion que ce n'est pas possible en temps polynomial.

Implications philosophiques sur la nature de la réflexion et de la créativité humaine
Une implication de P-NP concerne le problème de la décision, nommé souvent sous le terme original allemand d'Entscheidungsproblem. Ce problème, posé par le mathématicien David Hilbert en 1928, consiste à se demander s'il existe un algorithme qui, si on lui présente une question mathématique dont la réponse est Oui ou Non dans un langage formel, trouvera automatiquement et infailliblement la réponse. Un tel algorithme serait potentiellement en mesure, par exemple, de répondre à la question de savoir si la conjecture de Goldbach ou l'hypothèse de Riemann est vraie ou fausse (si ces problèmes sont décidables).
Il a été démontré que le problème de la décision n'a pas de réponse dans le cas général, pour toutes les questions exprimables dans un langage formel donné. Cette démonstration a été apportée en 1936, indépendamment, par Alan Turing et Alonzo Church. Ils démontrent qu'il y a toujours des questions algorithmiquement indécidables, dont un algorithme ne peut trouver la réponse, dans tout système formel cohérent et suffisamment puissant pour exprimer des questions intéressantes.
Une implication considérable de la démonstration de P-NP serait qu'il deviendrait envisageable de résoudre une forme réduite du problème de la décision, c'est-à-dire pour les questions dont la démonstration est courte. La vérification de la validité d'une démonstration est un problème polynomial par rapport à la longueur de la démonstration N, ce qui veut dire qu'étant donné N, trouver une démonstration de longueur N est un problème de la classe NP, dont la complexité est a priori exponentielle par rapport à N, car il existe de l'ordre de C N (-displaystyle C(N)) démonstrations possibles de longueur N (C étant dépendant du langage formel employé). Une recherche par force brute de la démonstration donne donc une complexité exponentielle à l'algorithme.
Mais si P-NP, alors il doit être possible de faire mieux qu'une recherche par force brute, et il existe alors un algorithme de complexité polynomiale par rapport à N pour trouver la démonstration. Si, donc, on se limite aux démonstrations de longueur N, N étant suffisamment grand pour être raisonnablement sûr que la démonstration n'est pas plus grande, alors un algorithme résolvant les problèmes NP-complets serait en mesure, dans un temps polynomial par rapport à N, de trouver la démonstration valide parmi les C N (-displaystyle C(N)) démonstrations possibles de longueur N.
Un grand nombre de questions mathématiques pourraient être alors résolues, automatiquement, dont vraisemblablement d'autres problèmes du prix du millénaire.
Plus philosophiquement, une démonstration mathématique peut être vue comme une codification d'un raisonnement humain plus général. Trouver un algorithme de démonstration automatique aurait des implications considérables pour tout ce qui concerne le raisonnement et la créativité humaine : il serait alors envisageable de laisser un ordinateur trouver des théories physiques, ou même composer de la musique, pour autant qu'un algorithme formel de vérification puisse être déterminé.

Implications de P NP
S'il est démontré que P NP, il serait alors impossible de résoudre tous les cas des problèmes NP-complets dans un temps polynomial, et ces problèmes seraient alors hors de la classe des problèmes qui peuvent être traités - théoriquement - de manière efficace.
Cela signifierait également qu'il est, fondamentalement, plus difficile de chercher la solution d'un problème que de vérifier cette solution.
Mais cette situation n'aurait pas que des inconvénients. La cryptographie à clé publique et la sécurité bancaire seraient assurées, mais plus encore : il est démontré que si P NP, chaque problème NP (et non P) a alors une preuve à divulgation nulle de connaissance assurée et démontrée, ce qui rend de grands services en matière d'authentification.
Une preuve de P NP serait également un approfondissement de la théorie de la complexité algorithmique : elle donnerait sans doute des réponses à la question de savoir pourquoi il est impossible de faire mieux que la force brute pour certains problèmes, et apporterait des pistes pour améliorer tout de même l'efficacité des algorithmes résolvant les problèmes NP-complets (sans les rendre polynomiaux pour autant, bien entendu) et pour démontrer plus formellement la sécurité des systèmes cryptographiques.
Cependant, il resterait à évaluer - sur le plan pratique - jusqu'à quel point les problèmes NP-complets pourraient être traités :

Problèmes intermédiaires
Ladner a démontré que si P NP, alors il existe des problèmes intermédiaires, ni NP-complet, ni dans P.

Temps moyen polynomial
Stephen Cook fait remarquer qu'il reste possible qu'il existe un algorithme résolvant les problèmes NP-complets dans un temps polynomial, dans une majorité de cas de figure. Il serait alors possible de conjecturer, et peut-être prouver, une forme plus faible du problème P-NP, où la question serait de savoir s'il existe un algorithme pour résoudre dans un temps en moyenne polynomial, des problèmes NP-complets qui ont une distribution raisonnable de cas de figure.

Algorithmes exponentiels rapides
Des algorithmes exponentiels rapides peuvent être plus efficaces en pratique que des algorithmes polynomiaux, pour une taille du problème restreinte correspondant à des cas pratiques. Par exemple, un algorithme en O (1 , 01 n) (-displaystyle O-left(1(,)01(n)-right)) peut être plus efficace en pratique qu'un algorithme en O (n 4) (-displaystyle O-left(n(4)-right)).
L'utilisation d'algorithmes probabilistes permet d'obtenir des algorithmes exponentiels plus rapides, pour certains problèmes, que les algorithmes déterministes. Par exemple, pour le problème SAT, l'algorithme déterministe le plus rapide est en O (1,472 6 n) (-displaystyle O-left(1(,)4726(n)-right)), alors que l'algorithme probabiliste le plus rapide est en O (1,322 2 n) (-displaystyle O-left(1(,)3222(n)-right)).
Dans le même ordre d'idées, la puissance absolue des ordinateurs permet, même avec un algorithme exponentiel, de trouver en pratique la solution pour des problèmes NP-complets pour tous les cas se présentant dans la vie courante : ainsi il est possible de résoudre le problème du voyageur de commerce pour des voyages allant jusqu'à 2 000 villes.
Toutefois, ces algorithmes exponentiels rapides ne permettent pas de remettre en cause la sécurité des algorithmes de cryptographie ou d'authentification par exemple, dans la mesure où la taille du problème peut être artificiellement et arbitrairement augmentée de manière à se trouver hors d'atteinte de la puissance brute des ordinateurs.

Algorithmes sous-exponentiels
Même si P NP, il reste possible (le contraire n'a pas été démontré) qu'il existe des algorithmes sous-exponentiels pour résoudre les problèmes NP-complets. Un algorithme est sous-exponentiel si le logarithme du temps d'exécution croît asymptotiquement moins vite que tout polynôme donné. Par exemple un algorithme en O (2 n) (-displaystyle O-left(2(n(-epsilon))-right)) avec 1 (-displaystyle -epsilon 1), ou O (n log (n)) (-displaystyle O-left(n(-log(n))-right)) serait sous-exponentiel. La classe des problèmes sous-exponentiels est notée SUBEXP. Jusqu'à présent, aucun algorithme de ce genre n'a été exhibé pour des problèmes démontrés NP-complets, mais il en existe pour des problèmes NP comme la décomposition en facteurs premiers (voir crible algébrique) ou le problème de l'isomorphisme de graphes, dont on ne sait pas s'ils sont NP-complets ou non.
Il existe cependant des conjectures qui sont reconnues comme probablement vraies, concernant l'existence d'algorithmes sous-exponentiels. Il existe une classe de problèmes SNP (Strict NP) qui regroupe la plupart des problèmes NP importants. On considère probable que SNP SUBEXP (-displaystyle (-text(SNP))-nsubseteq (-text(SUBEXP))), c'est-à-dire qu'un certain nombre de problèmes SNP ne possèdent pas d'algorithmes sous-exponentiels.
Si cette conjecture est vraie, alors il est démontré que le problème NP-complet de k-satisfaisabilité, avec k 3 (-displaystyle k-geq 3), ne peut être résolu par un algorithme sous-exponentiel, et par conséquent il en serait de même pour tous les problèmes NP-complets (par réduction).

Démonstrations non constructives d'existence d'algorithmes polynomiaux
Le théorème de Robertson-Seymour (démontré en 2004) permet de montrer l'existence d'algorithmes rapides (polynomiaux, et même cubiques) de résolution de sous-problèmes dont on sait que le cas général est NP-complet, voire NP-difficile. Ainsi, le problème des chemins disjoints, lequel consiste à déterminer, étant donné n paires de sommets, s'il existe dans le graphe n chemins disjoints les reliant deux à deux, est NP-complet ; le problème reste même NP-complet pour des graphes assez simples, mais Robertson et Seymour ont montré que, à k fixé, le problème des k chemins disjoints est effectivement soluble en temps polynomial ; cela ne prouve cependant pas que P - NP, car le temps pris par l'algorithme est un polynôme en n (la taille du graphe étudié) de la forme C (k) n 3 (-displaystyle C(k)n(3)), mais la constante C (k) (-displaystyle C(k)) augmente au moins exponentiellement avec k. De plus, leur théorème ne donne aucun moyen effectif de construire l'algorithme en question (il repose sur la détermination préalable, pour chaque valeur de k, d'un ensemble fixe de graphes, en nombre certes fini, mais qui peut être colossal).
Bien que le théorème de Robertson-Seymour n'ait pas vraiment apporté d'informations nouvelles concernant le problème P-NP, Fellows et Langston ont fait remarquer que leur démonstration non constructive d'existence d'algorithmes polynomiaux (et où apparaissent souvent, qui plus est, des constantes de proportionnalité bien trop grandes pour qu'ils puissent avoir une utilisation pratique quelconque) rend moins claire qu'auparavant la distinction entre algorithmes polynomiaux (considérés comme utilisables de manière réaliste) et non polynomiaux (à jamais inutilisables pour des ensembles de données un peu vastes), et donc que l'intuition de la majorité des informaticiens, selon laquelle la classe P est différente de la classe NP, pourrait bien se révéler fausse, sans pour autant que les problèmes NP-complets en deviennent faciles à résoudre.

Position des théoriciens sur ce problème
Les théoriciens de la complexité algorithmique pensent en majorité que P NP. Dans une enquête réalisée par William Gasarch en 2002 auprès de 100 théoriciens de la question, 61 d'entre eux ont déclaré penser que P NP, alors que seul 9 d'entre eux pensent que P-NP, les 30 restants ne souhaitant pas prendre position sur la question, ou penchant plutôt pour l'indécidabilité dans ZFC. C'est d'ailleurs ce relatif consensus qui justifie l'emploi de la cryptographie à clé publique pour sécuriser les transactions bancaires.
Les raisons de penser que P NP sont en effet assez nombreuses : Un argument qui revient souvent est que, sans a priori, si on défend l'idée que P-NP, on peut s'attendre à ce qu'un algorithme polynomial résolvant un problème NP-complet soit trouvable assez facilement, alors que, si on défend P NP, on s'attend à ce qu'il ne soit jamais trouvé. Le tableau de la situation, après plus de cinquante ans de recherches vaines en ce sens, est plus conforme et cohérent à P NP. Plus formellement, un article de Razborov et Rudich de 1993, qualifié par Scott Aaronson d'un des résultats les plus importants concernant le problème P-NP, tend à démontrer que la raison pour laquelle P NP est si difficile à démontrer, est que probablement P NP. Cet article montre une contradiction entre certaines conjectures très plausibles sur les générateurs de nombres pseudo-aléatoires et les procédés habituels de démonstration de P NP, appelé preuve naturelle. Si P NP est démontrable, alors ce sera nécessairement avec des méthodes nouvelles, très différentes des méthodes habituellement employées dans les démonstrations. Un argument plus philosophique s'appuie sur la considération qu'un monde où P-NP est très différent d'un monde où P NP. Dans un monde où P-NP, des capacités jusqu'ici réservées aux êtres humains (créativité, recherche...) sont potentiellement accessibles au calcul.

Indécidabilité de P-NP dans ZFC
Le fait qu'il soit très difficile de trouver une démonstration à P - NP ou P NP peut amener à envisager que ce problème soit indécidable dans le système le plus couramment utilisé en mathématique à savoir le système formel ZFC. Un problème indécidable est un problème dont la véracité ou la fausseté n'admet aucune démonstration dans un système formel donné. On parle aussi d'indépendance du problème par rapport au système formel. Si un problème est indécidable, on peut alors le prendre ou prendre sa négation comme nouvel axiome pour forger un nouveau système formel plus large. L'inéluctabilité de propositions indécidables en arithmétique a été démontrée par Gödel en 1931 par le célèbre théorème d'incomplétude.
Pendant longtemps, on a pensé que l'indécidabilité était réservée à des problèmes artificiels, spécialement conçus pour être indécidables. Cependant, depuis que l'hypothèse du continu a été démontrée indécidable par rapport au système formel ZFC en 1963, on sait que des problèmes mathématiques importants et fondamentaux peuvent être indécidables, et donc que leur véracité ou leur fausseté ne peut être établie.
Il n'est donc pas exclu que le problème P - NP soit indécidable dans ZFC, et que toute démonstration en soit impossible dans le système formel ZFC le plus utilisé par les mathématiciens. Un certain nombre de résultats viennent étayer cette possibilité, bien que la communauté des théoriciens pense en général que ce problème n'est pas indécidable dans ZFC (et continue par conséquent à en rechercher activement une démonstration).

Résultats en faveur de l'indécidabilité dans ZFC
R. DeMillo et R. Lipton ont démontré en 1979 que dans un certain système formel nommé EF, moins puissant que ZFC, mais suffisamment puissant pour démontrer beaucoup de problèmes mathématiques, le problème P - NP était indécidable. Malheureusement, EF a été artificiellement construit, et trop faible pour en tirer des conclusions significatives. Toutefois, ce résultat vient confirmer que, pour démontrer P - NP, il faudra utiliser des axiomes, qui ne sont pas des théorèmes de EF.
En théorie de la complexité algorithmique, on utilise des oracles qui invoquent des décisions hors de la complexité considérée. Par hypothèse, un oracle sait répondre instantanément à un problème déterminé (par exemple, la primalité d'un nombre ou le problème de l'arrêt). Pour chaque oracle O (-displaystyle O), il existe une classe de complexité P O (-displaystyle P-(O)), N P O (-displaystyle NP-(O)), etc. correspondant aux problèmes qui peuvent être résolus ou vérifiés en temps polynomial, en invoquant cet oracle.
Avec certains oracles et dans un système formel donné F, on peut démontrer que P O - N P O (-displaystyle P-(O)-NP-(O)), et avec d'autres que P O N P O (-displaystyle P-(O)-neq NP-(O)). C'est un résultat auquel on peut s'attendre si le problème P - NP est indécidable dans F, car toute démonstration du problème sans oracle devra pouvoir s'adapter aux cas avec oracle et donner deux résultats différents, ce qui est a priori très difficile, voire impossible. De plus, il a été démontré que le problème P O - N P O (-displaystyle P-(O)-NP-(O)) est indécidable avec certains oracles, dans ZFC, ce qui est considéré comme un argument en faveur de l'indécidabilité du problème. Il a été aussi démontré que si on choisit un oracle au hasard(précision nécessaire) alors P O N P O (-displaystyle P-(O)-neq NP-(O)) avec une probabilité de 1.

Résultats en faveur de la décidabilité dans ZFC
Toutefois, Jean-Paul Delahaye fait également remarquer que cette situation disparate où, en fonction des oracles, on peut démontrer des résultats différents peut ne pas être significative, car la situation de la démonstration du problème IP - PSPACE était très similaire avant que Adi Shamir parvienne à démontrer que ces deux ensembles sont égaux à l'aide de techniques en fait très simples. Selon Delahaye, cet exemple donne des raisons d'espérer non seulement que le problème P - NP est décidable, mais aussi que sa démonstration soit à notre portée.

Statut du problème par rapport à d'autres modèles de calcul

Informatique quantique
Relations supposées entre la classe BQP et les autres classes de complexité.
La classe des problèmes qui peuvent être résolus efficacement par des calculateurs quantiques est appelée BQP, pour "Bounded error, Quantum, Polynomial time" (littéralement : Erreur bornée, Quantum, Temps polynomial), et constitue la contrepartie de la classe de complexité BBP pour les ordinateurs classiques (les calculateurs quantiques exécutent uniquement des algorithmes probabilistes). La classe BQP est la classe des problèmes qui peuvent être résolus par un calculateur quantique en temps polynomial, avec une probabilité d'erreur d'au plus 1-3.
BQP est supposé disjoint de la classe NP-complet, et un sur-ensemble de la classe P (voir schéma), mais cela n'est pas démontré. La décomposition en produit de facteurs premiers est un problème de classe NP (mais on ne sait pas s'il est NP-complet), et BQP car il peut être résolu en temps polynomial par un algorithme quantique : l'algorithme de Shor. On pourrait donc être tenté de penser qu'un calculateur quantique serait en mesure de résoudre un problème NP-complet dans un temps polynomial.
Mais cet exemple ne donne pas d'indice édifiant en ce sens, car il se pourrait aussi que le problème de la décomposition en facteurs premier soit en fait de classe P, auquel cas l'algorithme de Shor n'apporterait rien par rapport à l'informatique classique. De plus, l'algorithme de Shor s'appuie lourdement sur la structure algébrique des nombres, ce qui n'est le cas d'aucun problème NP-complet connu. Mais comme il n'est pas démontré que BQP est disjoint de NP-complet, on ne peut non plus formellement écarter l'hypothèse que les problèmes NP-complets puissent être en théorie calculable par un ordinateur quantique en temps polynomial.
Toutefois, les théoriciens s'accordent pour penser que les algorithmes quantiques ne pourront résoudre les problèmes NP-complet en temps polynomial. Notamment, il existe un algorithme quantique qui s'applique aux problèmes NP-complet : l'algorithme de Grover, qui apporte une amélioration quadratique (2 n 2 (-displaystyle 2(-frac (n)(2))) au lieu de 2 n (-displaystyle 2(n))), mais qui reste néanmoins exponentiel. Il existe de forts indices selon lesquels on ne pourra pas aller plus loin en matière d'algorithme quantique.

Présentation formelle du problème utilisant des machines de Turing
Le problème P - N P (-displaystyle -mathrm (P-NP)) est "robuste" et peut-être posée pour des modèles de calcul équivalents aux ordinateurs actuels (essentiellement des modèles de calculs déterministes qui se simulent entre eux en temps polynomial). La présentation qui suit reprend essentiellement celle donnée par Stephen Cook pour l'institut Clay , qui utilise des machines de Turing déterministes à une bande infinie à droite, et dont l'ensemble des états contient en particulier deux états terminaux (la machine s'arrête quand elle est dans l'un de ces deux états), l'un acceptant et l'autre refusant. On note (-displaystyle -Sigma (-)) l'ensemble des mots sur l'alphabet (-displaystyle -Sigma). La longueur d'un mot w est notée w. La machine est supposée déterministe, c'est-à-dire qu'à une configuration de celle-ci, est associée une seule nouvelle configuration (éventuellement aucune), qui constitue une étape de calcul. On dit qu'un mot w (-displaystyle w-in -Sigma (-)) est reconnu par M (-displaystyle M), une machine de Turing, si l'exécution de M (-displaystyle M) avec w (-displaystyle w) en entrée se termine dans l'état acceptant en un nombre fini d'étapes (chaque étape correspond à une transition). Et on note L M (-displaystyle L-(M)) l'ensemble des mots de (-displaystyle -Sigma (-)) reconnus par M (-displaystyle M).; Pour tout mot w (-displaystyle w-in -Sigma (-)), on définit t M (w) (-displaystyle t-(M)(w)), le nombre d'étapes au bout duquel la machine de Turing M (-displaystyle M) avec entrée w (-displaystyle w) s'arrête, c'est-à-dire se trouve dans un état terminal, ce nombre d'étapes, ou temps de calcul, est infini si la machine ne s'arrête pas pour cette entrée. Un langage (sur) est un ensemble de mots, soit un sous-ensemble de. Un langage L est reconnu par une machine M, quand l'ensemble des mots reconnus par M est L (soit L - L(M)).; On dit qu'une machine de Turing M fonctionne en temps polynomial s'il existe un entier k tel que pour tout entier n et tout mot w de longueur inférieur ou égale à n le temps de calcul de la machine pour cette entrée est borné par n : w (w n t M (w) n k) (-displaystyle -forall w-in -Sigma (-ast)(w-leq n-Rightarrow t-(M)(w)-leq n(k))).; La classe P est l'ensemble des langages reconnus par une machine de Turing qui fonctionne en temps polynomial.; À toute relation binaire R (-displaystyle R) entre mots sur (-displaystyle -Sigma), est associée un langage LR sur l'alphabet (-) (-displaystyle -Sigma -cup -(--)), - étant un caractère de séparation n'appartenant pas à (-displaystyle -Sigma), par L R - (x - y x , y , R (x , y)) (-displaystyle L-(R)--(x-yx-in -Sigma (-),y-in -Sigma (-),R(x,y)-)). On dit que R (-displaystyle R) est reconnue en temps polynomial si L R P (-displaystyle L-(R)-in -mathrm (P)).; La classe NP est alors l'ensemble des langages L pour lesquels il existe un entier k, et une relation R reconnue en temps polynomial, tel que pour tout w, w L y (y w k e t R (w , y)) (-displaystyle w-in L-Leftrightarrow -exists y(yw(k)etR(w,y))).
Le problème P-NP consiste à déterminer si les classes P et NP sont ou non égales.

Voir aussi

Article connexe
Théorème de Ladner (de): Portail de la logique; Portail de l'informatique théorique.